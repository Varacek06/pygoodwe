{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pygoodwe A command line tool and python library to query the GOODWE SEMS Portal APIs. API Docs Auto-generated documentation is here: https://yaleman.github.io/pygoodwe/ Installation You need to have Python 3 and pip installed. Then: python -m pip install pygoodwe Determine the Station ID from the GOODWE site as follows. Open the Sems Portal . The Plant Status will reveal the Station ID in the URL. Example: https://www.semsportal.com/powerstation/powerstatussnmin/11112222-aaaa-bbbb-cccc-ddddeeeeeffff Then the Station ID is 11112222-aaaa-bbbb-cccc-ddddeeeeeffff . Contributions Please feel free to lodge an issue or pull request on GitHub . Thanks Originally based off the work of Mark Ruys and his gw2pvo software - I needed something more flexible, so I made this. Disclaimer GOODWE access is based on the undocumented API used by mobile apps. This could break at any time. Example Code Please check out test.py in the base of the repository for some simple example code.","title":"Home"},{"location":"#pygoodwe","text":"A command line tool and python library to query the GOODWE SEMS Portal APIs.","title":"pygoodwe"},{"location":"#api-docs","text":"Auto-generated documentation is here: https://yaleman.github.io/pygoodwe/","title":"API Docs"},{"location":"#installation","text":"You need to have Python 3 and pip installed. Then: python -m pip install pygoodwe Determine the Station ID from the GOODWE site as follows. Open the Sems Portal . The Plant Status will reveal the Station ID in the URL. Example: https://www.semsportal.com/powerstation/powerstatussnmin/11112222-aaaa-bbbb-cccc-ddddeeeeeffff Then the Station ID is 11112222-aaaa-bbbb-cccc-ddddeeeeeffff .","title":"Installation"},{"location":"#contributions","text":"Please feel free to lodge an issue or pull request on GitHub .","title":"Contributions"},{"location":"#thanks","text":"Originally based off the work of Mark Ruys and his gw2pvo software - I needed something more flexible, so I made this.","title":"Thanks"},{"location":"#disclaimer","text":"GOODWE access is based on the undocumented API used by mobile apps. This could break at any time.","title":"Disclaimer"},{"location":"#example-code","text":"Please check out test.py in the base of the repository for some simple example code.","title":"Example Code"},{"location":"CHANGELOG/","text":"Changelog 0.0.1 - 0.0.3 2019-10-09 Initial versions, basically just getting packaging and the most simple things working 0.0.4 2019-10-09 Fixed a bug that mis-identified the load generating power. 0.0.5 2019-10-09 Updated setup.py to build in a requirement for requests 0.0.6-0.0.7 2019-10-12 Updated SingleInverter to return battery state of charge, then fixed the fact I was implementing the same thing two different ways... 0.0.8 2019-10-12 I really should write some tests for this. Fixed SingleInverter.get_battery_soc() to actually work. 0.0.9 2019-10-12 Catching an error when the inverter data doesn't load. 0.0.10 ... not sure? 0.0.11 2019-11-05 Commented out some non-functional code. 0.0.12 2019-12-03 Removed the non-used code, fixed a bug. 0.0.13 2020-06-22 Added getPmeter from community submission, fixed a lot of pylint errors 0.0.14 2020-07-06 Updated API endpoint due to cert expiry/change of API from 'https://globalapi.sems.com.cn/api/'' to 'https://semsportal.com/api/' as the old one was throwing expired cert errors. 0.0.16 2021-02-04 Included option from Peter Verthez to download an Excel file of data, cleaned up some old code style mess. 0.0.17 2022-06-04 Fully typed, if a little janky, replaced flit packaging with poetry. 0.0.18 2022-06-28 Added mkdocs automagical documentation, bumped version to update details on pypi. 0.1.0 2022-10-05 Fixed issue with getDataPvoutput on SingleInverters. (#148)","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"0.0.1 - 0.0.3 2019-10-09 Initial versions, basically just getting packaging and the most simple things working 0.0.4 2019-10-09 Fixed a bug that mis-identified the load generating power. 0.0.5 2019-10-09 Updated setup.py to build in a requirement for requests 0.0.6-0.0.7 2019-10-12 Updated SingleInverter to return battery state of charge, then fixed the fact I was implementing the same thing two different ways... 0.0.8 2019-10-12 I really should write some tests for this. Fixed SingleInverter.get_battery_soc() to actually work. 0.0.9 2019-10-12 Catching an error when the inverter data doesn't load. 0.0.10 ... not sure? 0.0.11 2019-11-05 Commented out some non-functional code. 0.0.12 2019-12-03 Removed the non-used code, fixed a bug. 0.0.13 2020-06-22 Added getPmeter from community submission, fixed a lot of pylint errors 0.0.14 2020-07-06 Updated API endpoint due to cert expiry/change of API from 'https://globalapi.sems.com.cn/api/'' to 'https://semsportal.com/api/' as the old one was throwing expired cert errors. 0.0.16 2021-02-04 Included option from Peter Verthez to download an Excel file of data, cleaned up some old code style mess. 0.0.17 2022-06-04 Fully typed, if a little janky, replaced flit packaging with poetry. 0.0.18 2022-06-28 Added mkdocs automagical documentation, bumped version to update details on pypi. 0.1.0 2022-10-05 Fixed issue with getDataPvoutput on SingleInverters. (#148)","title":"Changelog"},{"location":"pygoodwe/","text":"pygoodwe: a (terrible) interface to the goodwe solar API API API implementation Source code in pygoodwe/__init__.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 class API (): \"\"\" API implementation \"\"\" #pylint: disable=too-many-instance-attributes,too-many-arguments def __init__ ( self , system_id : str , account : str , password : str , api_url : str = API_URL , log_level : Optional [ str ] = None , user_agent : str = DEFAULT_UA , skipload : bool = False , ) -> None : \"\"\" Options: skipload: don't run self.getCurrentReadings() on init api_url: you can change the API endpoint it hits \"\"\" #TODO: lang: Real Soon Now it'll filter out any responses without that language if log_level is None : if \"LOG_LEVEL\" in os . environ : log_level = os . environ [ \"LOG_LEVEL\" ] else : log_level = \"INFO\" if log_level in ( \"DEBUG\" , \"INFO\" , \"WARNING\" ): log_level = getattr ( logging , os . getenv ( \"LOG_LEVEL\" , \"INFO\" )) logging . basicConfig ( level = log_level , ) self . session = Session () self . system_id = system_id self . account = account self . password = password self . token = '{\"version\":\"v2.0.4\",\"client\":\"ios\",\"language\":\"en\"}' self . global_url = api_url self . base_url = self . global_url logging . debug ( \"API URL: %s \" , self . base_url ) self . user_agent = user_agent if skipload : logging . debug ( \"Skipping initial load of data\" ) self . data : Dict [ str , Any ] = {} else : logging . debug ( \"Doing load of data\" ) self . getCurrentReadings ( raw = True ) def loaddata ( self , filename : str ) -> None : \"\"\" loads a json file of existing data \"\"\" with open ( filename , \"r\" , encoding = \"utf8\" ) as filehandle : self . data = json . loads ( filehandle . read ()) _loaddata = loaddata def get_current_readings ( self , raw : bool = True , retry : int = 1 , maxretries : int = 5 , delay : int = 30 , ) -> Dict [ str , Any ]: # pylint: disable=invalid-name \"\"\" gets readings at the current point in time \"\"\" payload = { \"powerStationId\" : self . system_id } # GOODWE server self . data = self . call ( \"v1/PowerStation/GetMonitorDetailByPowerstationId\" , payload ) retval = self . data if not self . data . get ( \"inverter\" ): if retry < maxretries : logging . error ( \"no inverter data, try %s , trying again in %s seconds\" , retry , delay ) time . sleep ( delay ) retval = self . getCurrentReadings ( raw = raw , retry = retry + 1 , maxretries = maxretries , delay = delay ) else : logging . error ( \"No inverter data after %s retries, quitting.\" , retry ) sys . exit ( f \"No inverter data after { retry } retries, quitting.\" ) return retval # stub function names to old names getCurrentReadings = get_current_readings # def getDayReadings(self, date): # date_s = date.strftime('%Y-%m-%d') # payload = { # 'powerStationId' : self.system_id # } # data = self.call(\"v1/PowerStation/GetMonitorDetailByPowerstationId\", payload) # if 'info' not in data: # logging.warning(date_s + \" - Received bad data \" + str(data)) # return result # result = { # 'latitude' : data['info'].get('latitude'), # 'longitude' : data['info'].get('longitude'), # 'entries' : [] # } # payload = { # 'powerstation_id' : self.system_id, # 'count' : 1, # 'date' : date_s # } # data = self.call(\"PowerStationMonitor/GetPowerStationPowerAndIncomeByDay\", payload) # if len(data) == 0: # logging.warning(date_s + \" - Received bad data \" + str(data)) # return result # eday_kwh = data[0]['p'] # payload = { # 'id' : self.system_id, # 'date' : date_s # } # data = self.call(\"PowerStationMonitor/GetPowerStationPacByDayForApp\", payload) # if 'pacs' not in data: # logging.warning(date_s + \" - Received bad data \" + str(data)) # return result # minutes = 0 # eday_from_power = 0 # for sample in data['pacs']: # parsed_date = datetime.strptime(sample['date'], \"%m/%d/%Y %H:%M:%S\") # next_minutes = parsed_date.hour * 60 + parsed_date.minute # sample['minutes'] = next_minutes - minutes # minutes = next_minutes # eday_from_power += sample['pac'] * sample['minutes'] # factor = eday_kwh / eday_from_power if eday_from_power > 0 else 1 # eday_kwh = 0 # for sample in data['pacs']: # date += timedelta(minutes=sample['minutes']) # pgrid_w = sample['pac'] # increase = pgrid_w * sample['minutes'] * factor # if increase > 0: # eday_kwh += increase # result['entries'].append({ # 'dt' : date, # 'pgrid_w': pgrid_w, # 'eday_kwh': round(eday_kwh, 3) # }) # return result @property def headers ( self ) -> Dict [ str , str ]: \"\"\" request headers \"\"\" return { \"User-Agent\" : self . user_agent , \"Token\" : self . token , } # pylint: disable=invalid-name def getDayDetailedReadingsExcel ( self , export_date : date , timeout : int = 10 , filename : Optional [ str ] = None , ) -> bool : \"\"\"retrieves the detailed daily results of the given date as an Excel sheet, processing the Excel sheet is outside the scope of the current module, possible args: - filename: the path where to write the output file, default \"./Plant_Power_{datestr}.xls \"\"\" datestr = datetime . strftime ( export_date , \"%Y-%m- %d \" ) if filename is None : filename = f \"Plant_Power_ { datestr } .xls\" logging . debug ( \"Will write data for %s to file: %s \" , datestr , filename ) # {\"api\":\"v1/PowerStation/ExportPowerstationPac\",\"param\":{\"date\":\"2021-12-20\",\"pw_id\":\"<my-pw-id>\" payload = { \"str\" : json . dumps ({ \"api\" : \"v1/PowerStation/ExportPowerstationPac\" , \"param\" : { \"date\" : datestr , \"pw_id\" : self . system_id , # since the chart can't be included, use some fixed values that make the sheet look good without it # single pixel white png \"img_base64\" : \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdj+P///38ACfsD/QVDRcoAAAAASUVORK5CYII=\" , #pylint: disable=line-too-long \"img_width\" : 1 , \"img_height\" : 1 , \"is_removesoc\" : 0 , } }) } logging . error ( \"payload: %s \" , payload ) # grab the ID of a file download with the export in it fixed_api_endpoint = self . base_url . replace ( \"/api/\" , \"/GopsApi/Post\" ) # full_url = f\"{fixed_api_endpoint}\" response = requests . post ( url = fixed_api_endpoint , # full_url, params = { \"s\" : \"v1/PowerStation/ExportPowerstationPac\" }, headers = self . headers , data = payload , timeout = timeout , ) response . raise_for_status () # logging.error(response.content) try : data = response . json () except JSONDecodeError : logging . error ( \"Failed to JSON decode result from %s : \\n %s \" , fixed_api_endpoint , response . content , ) return False if not data . get ( \"msg\" ) . lower in ( \"success\" , \"successful\" ): logging . error ( \"Failed to pull from %s - response - %s \" , fixed_api_endpoint , data ) return False download_id = data . get ( \"data\" ) logging . error ( \"Download ID: %s \" , download_id ) if not download_id : logging . error ( \"Couldn't pull download ID by calling %s \" , fixed_api_endpoint ) logging . error ( json . dumps ( download_id )) return False download_payload = { \"id\" : download_id , } file_data = self . call ( \"v1/ReportData/GetStationPowerDataFilePath\" , download_payload , timeout = timeout , ) if file_data and \"file_path\" in file_data : # this is where we actually download the file try : response = requests . get ( file_data [ \"file_path\" ], allow_redirects = True , timeout = timeout , ) response . raise_for_status () except Exception as error_message : # pylint: disable=broad-except logging . error ( \"Failed to query file download path: %s \" , error_message ) # write the file to disk try : with open ( filename , \"wb\" ) as file_handle : file_handle . write ( response . content ) return True except Exception as error_message : # pylint: disable=broad-except logging . error ( \"Failed to write file %s ! Error: %s \" , filename , error_message ) return False return False def do_login ( self , timeout : int = 10 ) -> bool : \"\"\" does the login and token saving thing \"\"\" login_payload = { \"account\" : self . account , \"pwd\" : self . password , } try : response = self . session . post ( self . global_url + \"v1/Common/CrossLogin\" , headers = self . headers , data = login_payload , timeout = timeout , ) response . raise_for_status () except requests . exceptions . RequestException as exp : logging . error ( \"RequestException during do_login(): %s \" , exp ) return False data = response . json () logging . error ( response . cookies ) if data . get ( \"api\" ): logging . debug ( \"Setting base url to %s \" , data . get ( \"api\" )) self . base_url = data . get ( \"api\" ) self . token = json . dumps ( data . get ( \"data\" )) logging . error ( \"Done login, token: %s \" , self . token ) return True def call ( self , url : str , payload : Any , max_tries : int = 3 , timeout : int = 10 , ) -> Dict [ str , Any ]: # pylint: disable=unused-argument \"\"\" makes a call to the API \"\"\" for i in range ( 1 , max_tries ): try : logging . debug ( \"Pulling the following URL: base_url=' %s ', url=' %s '\" , self . base_url , url , ) response = self . session . post ( self . base_url + url , headers = self . headers , data = payload , timeout = timeout , ) response . raise_for_status () data = response . json () logging . debug ( \"call response.json(): %s \" , json . dumps ( data )) # APIs return \"success\", \"Success\", \"Successful\" in the 'msg' # seen \"Successful\" in ExportPowerStationPac # logging.error(\"Msg result %s - %s\", self.base_url + url, data.get('msg', '')) if data . get ( \"msg\" , \"\" ) . lower () in ( \"success\" , \"successful\" , ) and \"data\" in data : # pylint: disable=no-else-return logging . debug ( \"Returning data: %s \" , json . dumps ( data [ \"data\" ], default = str ) ) result : Dict [ str , Any ] = data . get ( \"data\" ) return result logging . debug ( json . dumps ( data )) logging . debug ( \"Logging in again...\" ) if not self . do_login (): logging . error ( \"Failed to log in, bailing\" ) return {} except requests . exceptions . RequestException as exp : logging . error ( \"RequestException: %s \" , exp ) logging . debug ( \"Sleeping for %s seconds...\" , i ) time . sleep ( i ) logging . error ( \"Failed to call GoodWe API url=' %s '\" , self . base_url + url ) return {} @classmethod def parseValue ( cls , value : str , unit : str ) -> float : # pylint: disable=invalid-name \"\"\" takes a string value and reutrns it as a float (if possible) \"\"\" try : return float ( value . rstrip ( unit )) except ValueError as exp : logging . warning ( \"ValueError: %s \" , exp ) return 0.0 def are_batteries_full ( self , fullstate : float = 100.0 ) -> bool : \"\"\"boolean result for if the batteries are full. you can set your given 'full' percentage in float if you want to lower this a little are_batteries_full(fullstate=90.0): returns bool \"\"\" for battery in self . get_batteries_soc (): if battery < fullstate : return False return True def _get_batteries_soc ( self ) -> List [ float ]: \"\"\"returns a list of the state of charge for the batteries returns: list[float,] \"\"\" if not self . data : self . getCurrentReadings () if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"soc\" )) for inverter in self . data [ \"inverter\" ] ] def get_batteries_soc ( self ) -> List [ float ]: \"\"\" return the battery state of charge \"\"\" return self . _get_batteries_soc () def getPVFlow ( self ) -> float : # pylint: disable=invalid-name \"\"\" PV flow data \"\"\" raise NotImplementedError ( \"SingleInverter has this, multi does not\" ) def getVoltage ( self ) -> List [ float ]: # pylint: disable=invalid-name \"\"\" returns the a list of the first AC channel voltages \"\"\" if not self . data : self . getCurrentReadings ( True ) if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"vac1\" )) for inverter in self . data [ \"inverter\" ] ] def getPmeter ( self ) -> float : # pylint: disable=invalid-name \"\"\" gets the current line pmeter \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data . get ( \"inverter\" , {}) . get ( \"invert_full\" , {}) . get ( \"pmeter\" )) def getLoadFlow ( self ) -> List [ float ]: # pylint: disable=invalid-name \"\"\" returns the list of inverter multi-unit load watts \"\"\" raise NotImplementedError ( \"multi-unit load watts isn't implemented yet\" ) def get_inverter_temperature ( self ) -> List [ float ]: \"\"\" returns the list of inverter temperatures \"\"\" if not self . data : self . get_current_readings ( True ) if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"tempperature\" )) for inverter in self . data [ \"inverter\" ] ] def getDataPvoutput ( self ) -> Dict [ str , Union [ str , float ]]: # pylint: disable=invalid-name \"\"\"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage \"\"\" if not self . data : self . getCurrentReadings () # \"time\": \"10/04/2019 14:37:29\" timestamp = datetime . strptime ( self . data . get ( \"info\" , {}) . get ( \"time\" ), \"%m/ %d /%Y %H:%M:%S\" ) data : Dict [ str , Union [ str , float ]] = {} data [ \"d\" ] = timestamp . strftime ( \"%Y%m %d \" ) # date data [ \"t\" ] = timestamp . strftime ( \"%H:%M\" ) # time data [ \"v2\" ] = self . getPVFlow () # PV Generation data [ \"v4\" ] = self . getLoadFlow ()[ 0 ] # power consumption data [ \"v5\" ] = self . get_inverter_temperature ()[ 0 ] # inverter temperature data [ \"v6\" ] = self . getVoltage ()[ 0 ] # voltage return data __init__ ( system_id , account , password , api_url = API_URL , log_level = None , user_agent = DEFAULT_UA , skipload = False ) Options: skipload: don't run self.getCurrentReadings() on init api_url: you can change the API endpoint it hits Source code in pygoodwe/__init__.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def __init__ ( self , system_id : str , account : str , password : str , api_url : str = API_URL , log_level : Optional [ str ] = None , user_agent : str = DEFAULT_UA , skipload : bool = False , ) -> None : \"\"\" Options: skipload: don't run self.getCurrentReadings() on init api_url: you can change the API endpoint it hits \"\"\" #TODO: lang: Real Soon Now it'll filter out any responses without that language if log_level is None : if \"LOG_LEVEL\" in os . environ : log_level = os . environ [ \"LOG_LEVEL\" ] else : log_level = \"INFO\" if log_level in ( \"DEBUG\" , \"INFO\" , \"WARNING\" ): log_level = getattr ( logging , os . getenv ( \"LOG_LEVEL\" , \"INFO\" )) logging . basicConfig ( level = log_level , ) self . session = Session () self . system_id = system_id self . account = account self . password = password self . token = '{\"version\":\"v2.0.4\",\"client\":\"ios\",\"language\":\"en\"}' self . global_url = api_url self . base_url = self . global_url logging . debug ( \"API URL: %s \" , self . base_url ) self . user_agent = user_agent if skipload : logging . debug ( \"Skipping initial load of data\" ) self . data : Dict [ str , Any ] = {} else : logging . debug ( \"Doing load of data\" ) self . getCurrentReadings ( raw = True ) are_batteries_full ( fullstate = 100.0 ) boolean result for if the batteries are full. you can set your given 'full' percentage in float if you want to lower this a little are_batteries_full(fullstate=90.0): returns bool Source code in pygoodwe/__init__.py 370 371 372 373 374 375 376 377 378 def are_batteries_full ( self , fullstate : float = 100.0 ) -> bool : \"\"\"boolean result for if the batteries are full. you can set your given 'full' percentage in float if you want to lower this a little are_batteries_full(fullstate=90.0): returns bool \"\"\" for battery in self . get_batteries_soc (): if battery < fullstate : return False return True call ( url , payload , max_tries = 3 , timeout = 10 ) makes a call to the API Source code in pygoodwe/__init__.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def call ( self , url : str , payload : Any , max_tries : int = 3 , timeout : int = 10 , ) -> Dict [ str , Any ]: # pylint: disable=unused-argument \"\"\" makes a call to the API \"\"\" for i in range ( 1 , max_tries ): try : logging . debug ( \"Pulling the following URL: base_url=' %s ', url=' %s '\" , self . base_url , url , ) response = self . session . post ( self . base_url + url , headers = self . headers , data = payload , timeout = timeout , ) response . raise_for_status () data = response . json () logging . debug ( \"call response.json(): %s \" , json . dumps ( data )) # APIs return \"success\", \"Success\", \"Successful\" in the 'msg' # seen \"Successful\" in ExportPowerStationPac # logging.error(\"Msg result %s - %s\", self.base_url + url, data.get('msg', '')) if data . get ( \"msg\" , \"\" ) . lower () in ( \"success\" , \"successful\" , ) and \"data\" in data : # pylint: disable=no-else-return logging . debug ( \"Returning data: %s \" , json . dumps ( data [ \"data\" ], default = str ) ) result : Dict [ str , Any ] = data . get ( \"data\" ) return result logging . debug ( json . dumps ( data )) logging . debug ( \"Logging in again...\" ) if not self . do_login (): logging . error ( \"Failed to log in, bailing\" ) return {} except requests . exceptions . RequestException as exp : logging . error ( \"RequestException: %s \" , exp ) logging . debug ( \"Sleeping for %s seconds...\" , i ) time . sleep ( i ) logging . error ( \"Failed to call GoodWe API url=' %s '\" , self . base_url + url ) return {} do_login ( timeout = 10 ) does the login and token saving thing Source code in pygoodwe/__init__.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def do_login ( self , timeout : int = 10 ) -> bool : \"\"\" does the login and token saving thing \"\"\" login_payload = { \"account\" : self . account , \"pwd\" : self . password , } try : response = self . session . post ( self . global_url + \"v1/Common/CrossLogin\" , headers = self . headers , data = login_payload , timeout = timeout , ) response . raise_for_status () except requests . exceptions . RequestException as exp : logging . error ( \"RequestException during do_login(): %s \" , exp ) return False data = response . json () logging . error ( response . cookies ) if data . get ( \"api\" ): logging . debug ( \"Setting base url to %s \" , data . get ( \"api\" )) self . base_url = data . get ( \"api\" ) self . token = json . dumps ( data . get ( \"data\" )) logging . error ( \"Done login, token: %s \" , self . token ) return True getDataPvoutput () updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage Source code in pygoodwe/__init__.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 def getDataPvoutput ( self ) -> Dict [ str , Union [ str , float ]]: # pylint: disable=invalid-name \"\"\"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage \"\"\" if not self . data : self . getCurrentReadings () # \"time\": \"10/04/2019 14:37:29\" timestamp = datetime . strptime ( self . data . get ( \"info\" , {}) . get ( \"time\" ), \"%m/ %d /%Y %H:%M:%S\" ) data : Dict [ str , Union [ str , float ]] = {} data [ \"d\" ] = timestamp . strftime ( \"%Y%m %d \" ) # date data [ \"t\" ] = timestamp . strftime ( \"%H:%M\" ) # time data [ \"v2\" ] = self . getPVFlow () # PV Generation data [ \"v4\" ] = self . getLoadFlow ()[ 0 ] # power consumption data [ \"v5\" ] = self . get_inverter_temperature ()[ 0 ] # inverter temperature data [ \"v6\" ] = self . getVoltage ()[ 0 ] # voltage return data getDayDetailedReadingsExcel ( export_date , timeout = 10 , filename = None ) retrieves the detailed daily results of the given date as an Excel sheet, processing the Excel sheet is outside the scope of the current module, possible args: - filename: the path where to write the output file, default \"./Plant_Power_{datestr}.xls Source code in pygoodwe/__init__.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def getDayDetailedReadingsExcel ( self , export_date : date , timeout : int = 10 , filename : Optional [ str ] = None , ) -> bool : \"\"\"retrieves the detailed daily results of the given date as an Excel sheet, processing the Excel sheet is outside the scope of the current module, possible args: - filename: the path where to write the output file, default \"./Plant_Power_{datestr}.xls \"\"\" datestr = datetime . strftime ( export_date , \"%Y-%m- %d \" ) if filename is None : filename = f \"Plant_Power_ { datestr } .xls\" logging . debug ( \"Will write data for %s to file: %s \" , datestr , filename ) # {\"api\":\"v1/PowerStation/ExportPowerstationPac\",\"param\":{\"date\":\"2021-12-20\",\"pw_id\":\"<my-pw-id>\" payload = { \"str\" : json . dumps ({ \"api\" : \"v1/PowerStation/ExportPowerstationPac\" , \"param\" : { \"date\" : datestr , \"pw_id\" : self . system_id , # since the chart can't be included, use some fixed values that make the sheet look good without it # single pixel white png \"img_base64\" : \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdj+P///38ACfsD/QVDRcoAAAAASUVORK5CYII=\" , #pylint: disable=line-too-long \"img_width\" : 1 , \"img_height\" : 1 , \"is_removesoc\" : 0 , } }) } logging . error ( \"payload: %s \" , payload ) # grab the ID of a file download with the export in it fixed_api_endpoint = self . base_url . replace ( \"/api/\" , \"/GopsApi/Post\" ) # full_url = f\"{fixed_api_endpoint}\" response = requests . post ( url = fixed_api_endpoint , # full_url, params = { \"s\" : \"v1/PowerStation/ExportPowerstationPac\" }, headers = self . headers , data = payload , timeout = timeout , ) response . raise_for_status () # logging.error(response.content) try : data = response . json () except JSONDecodeError : logging . error ( \"Failed to JSON decode result from %s : \\n %s \" , fixed_api_endpoint , response . content , ) return False if not data . get ( \"msg\" ) . lower in ( \"success\" , \"successful\" ): logging . error ( \"Failed to pull from %s - response - %s \" , fixed_api_endpoint , data ) return False download_id = data . get ( \"data\" ) logging . error ( \"Download ID: %s \" , download_id ) if not download_id : logging . error ( \"Couldn't pull download ID by calling %s \" , fixed_api_endpoint ) logging . error ( json . dumps ( download_id )) return False download_payload = { \"id\" : download_id , } file_data = self . call ( \"v1/ReportData/GetStationPowerDataFilePath\" , download_payload , timeout = timeout , ) if file_data and \"file_path\" in file_data : # this is where we actually download the file try : response = requests . get ( file_data [ \"file_path\" ], allow_redirects = True , timeout = timeout , ) response . raise_for_status () except Exception as error_message : # pylint: disable=broad-except logging . error ( \"Failed to query file download path: %s \" , error_message ) # write the file to disk try : with open ( filename , \"wb\" ) as file_handle : file_handle . write ( response . content ) return True except Exception as error_message : # pylint: disable=broad-except logging . error ( \"Failed to write file %s ! Error: %s \" , filename , error_message ) return False return False getLoadFlow () returns the list of inverter multi-unit load watts Source code in pygoodwe/__init__.py 418 419 420 def getLoadFlow ( self ) -> List [ float ]: # pylint: disable=invalid-name \"\"\" returns the list of inverter multi-unit load watts \"\"\" raise NotImplementedError ( \"multi-unit load watts isn't implemented yet\" ) getPVFlow () PV flow data Source code in pygoodwe/__init__.py 397 398 399 def getPVFlow ( self ) -> float : # pylint: disable=invalid-name \"\"\" PV flow data \"\"\" raise NotImplementedError ( \"SingleInverter has this, multi does not\" ) getPmeter () gets the current line pmeter Source code in pygoodwe/__init__.py 412 413 414 415 416 def getPmeter ( self ) -> float : # pylint: disable=invalid-name \"\"\" gets the current line pmeter \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data . get ( \"inverter\" , {}) . get ( \"invert_full\" , {}) . get ( \"pmeter\" )) getVoltage () returns the a list of the first AC channel voltages Source code in pygoodwe/__init__.py 401 402 403 404 405 406 407 408 409 410 def getVoltage ( self ) -> List [ float ]: # pylint: disable=invalid-name \"\"\" returns the a list of the first AC channel voltages \"\"\" if not self . data : self . getCurrentReadings ( True ) if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"vac1\" )) for inverter in self . data [ \"inverter\" ] ] get_batteries_soc () return the battery state of charge Source code in pygoodwe/__init__.py 393 394 395 def get_batteries_soc ( self ) -> List [ float ]: \"\"\" return the battery state of charge \"\"\" return self . _get_batteries_soc () get_current_readings ( raw = True , retry = 1 , maxretries = 5 , delay = 30 ) gets readings at the current point in time Source code in pygoodwe/__init__.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get_current_readings ( self , raw : bool = True , retry : int = 1 , maxretries : int = 5 , delay : int = 30 , ) -> Dict [ str , Any ]: # pylint: disable=invalid-name \"\"\" gets readings at the current point in time \"\"\" payload = { \"powerStationId\" : self . system_id } # GOODWE server self . data = self . call ( \"v1/PowerStation/GetMonitorDetailByPowerstationId\" , payload ) retval = self . data if not self . data . get ( \"inverter\" ): if retry < maxretries : logging . error ( \"no inverter data, try %s , trying again in %s seconds\" , retry , delay ) time . sleep ( delay ) retval = self . getCurrentReadings ( raw = raw , retry = retry + 1 , maxretries = maxretries , delay = delay ) else : logging . error ( \"No inverter data after %s retries, quitting.\" , retry ) sys . exit ( f \"No inverter data after { retry } retries, quitting.\" ) return retval get_inverter_temperature () returns the list of inverter temperatures Source code in pygoodwe/__init__.py 422 423 424 425 426 427 428 429 430 431 def get_inverter_temperature ( self ) -> List [ float ]: \"\"\" returns the list of inverter temperatures \"\"\" if not self . data : self . get_current_readings ( True ) if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"tempperature\" )) for inverter in self . data [ \"inverter\" ] ] headers () property request headers Source code in pygoodwe/__init__.py 173 174 175 176 177 178 179 @property def headers ( self ) -> Dict [ str , str ]: \"\"\" request headers \"\"\" return { \"User-Agent\" : self . user_agent , \"Token\" : self . token , } loaddata ( filename ) loads a json file of existing data Source code in pygoodwe/__init__.py 77 78 79 80 def loaddata ( self , filename : str ) -> None : \"\"\" loads a json file of existing data \"\"\" with open ( filename , \"r\" , encoding = \"utf8\" ) as filehandle : self . data = json . loads ( filehandle . read ()) parseValue ( value , unit ) classmethod takes a string value and reutrns it as a float (if possible) Source code in pygoodwe/__init__.py 361 362 363 364 365 366 367 368 @classmethod def parseValue ( cls , value : str , unit : str ) -> float : # pylint: disable=invalid-name \"\"\" takes a string value and reutrns it as a float (if possible) \"\"\" try : return float ( value . rstrip ( unit )) except ValueError as exp : logging . warning ( \"ValueError: %s \" , exp ) return 0.0 SingleInverter Bases: API API implementation for an account with a single inverter Source code in pygoodwe/__init__.py 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 class SingleInverter ( API ): \"\"\" API implementation for an account with a single inverter \"\"\" # pylint: disable=too-many-arguments def __init__ ( self , system_id : str , account : str , password : str , api_url : str = API_URL , log_level : Optional [ str ] = None , user_agent : str = DEFAULT_UA , skipload : bool = False , ) -> None : self . loadflow = 0.0 self . loadflow_direction = \"\" self . data : Dict [ str , Any ] # instantiate the base class super () . __init__ ( system_id , account , password , api_url , log_level , user_agent , skipload ) def loaddata ( self , filename : str ) -> None : \"\"\" loads the ata from a given file \"\"\" self . _loaddata ( filename ) if self . data . get ( \"inverter\" ): self . data [ \"inverter\" ] = self . data [ \"inverter\" ][ 0 ] def get_current_readings ( self , raw : bool = True , retry : int = 1 , maxretries : int = 5 , delay : int = 30 , ) -> Any : \"\"\" grabs the data and makes sure self.data only has a single inverter \"\"\" # update the data super () . get_current_readings ( raw ) # reduce self.data['inverter'] to a single dict from a list retval = False if self . data . get ( \"inverter\" ): self . data [ \"inverter\" ] = self . data [ \"inverter\" ][ 0 ] else : if retry < maxretries : logging . error ( \"no inverter data, try %s , trying again in %s seconds\" , retry , delay ) time . sleep ( delay ) retval = self . get_current_readings ( raw = raw , retry = retry + 1 , maxretries = maxretries , delay = delay ) else : logging . error ( \"No inverter data after %s retries, quitting.\" , retry ) sys . exit ( f \"No inverter data after { retry } retries, quitting.\" ) return retval getCurrentReadings = get_current_readings def _get_station_location ( self ) -> Dict [ str , Union [ str , int ]]: \"\"\" gets the identified lat and long from the station data \"\"\" return self . get_station_location () def get_station_location ( self ) -> Dict [ str , Union [ str , int ]]: \"\"\" gets the identified lat and long from the station data \"\"\" if not self . data : self . getCurrentReadings () return { \"latitude\" : self . data . get ( \"info\" , {}) . get ( \"latitude\" ), \"longitude\" : self . data . get ( \"info\" , {}) . get ( \"longitude\" ), } def getPVFlow ( self ) -> float : \"\"\" returns the current flow amount of the PV panels \"\"\" if not self . data : self . getCurrentReadings () if self . data [ \"powerflow\" ][ \"pv\" ] . endswith ( \"(W)\" ): pvflow = self . data [ \"powerflow\" ][ \"pv\" ][: - 3 ] else : pvflow = self . data [ \"powerflow\" ][ \"pv\" ] return float ( pvflow ) def getVoltage ( self ) -> float : #type: ignore \"\"\" gets the current line voltage \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ \"inverter\" ][ \"invert_full\" ][ \"vac1\" ]) def get_day_income ( self ) -> float : \"\"\" gets the current daily income \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'day_income' ]) def get_total_income ( self ) -> float : \"\"\" gets the total income \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'total_income' ]) def get_total_power ( self ) -> float : \"\"\" gets the total power generated\"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'total_power' ]) def get_day_power ( self ) -> float : \"\"\" gets the total power generated\"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'power' ]) def getLoadFlow ( self ) -> float : # type: ignore if not self . data : self . getCurrentReadings () if self . data [ \"powerflow\" ][ \"bettery\" ] . endswith ( \"(W)\" ): loadflow = float ( self . data [ \"powerflow\" ][ \"load\" ][: - 3 ]) else : loadflow = float ( self . data [ \"powerflow\" ][ \"load\" ]) # I'd love to see the *house* generate power if self . data [ \"powerflow\" ][ \"loadStatus\" ] == - 1 : loadflow_direction = \"Importing\" elif self . data [ \"powerflow\" ][ \"loadStatus\" ] == 1 : loadflow_direction = \"Using Battery\" else : raise ValueError ( f \"Your 'load' is doing something odd - status is ' { self . data [ 'powerflow' ][ 'loadStatus' ] } ''.\" ) # pylint: disable=line-too-long self . loadflow = loadflow self . loadflow_direction = loadflow_direction return loadflow def _get_batteries_soc ( self ) -> float : #type: ignore \"\"\"returns the state of charge of the battery\"\"\" if not self . data : self . getCurrentReadings () if not self . data . get ( \"soc\" , False ): raise ValueError ( \"No state of charge available from data\" ) return float ( self . data [ \"soc\" ] . get ( \"power\" )) def get_battery_soc ( self ) -> float : \"\"\"returns the single value state of charge for the batteries in the plant returns : float \"\"\" return self . _get_batteries_soc () def get_inverter_temperature ( self ) -> float : #type: ignore if not self . data : self . get_current_readings ( True ) return float ( self . data [ \"inverter\" ][ \"tempperature\" ]) def getDataPvoutput ( self ) -> Dict [ str , Union [ str , float ]]: # pylint: disable=invalid-name \"\"\"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage \"\"\" if not self . data : self . getCurrentReadings () # \"time\": \"10/04/2019 14:37:29\" timestamp = datetime . strptime ( self . data . get ( \"info\" , {}) . get ( \"time\" ), \"%m/ %d /%Y %H:%M:%S\" ) data : Dict [ str , Union [ str , float ]] = {} data [ \"d\" ] = timestamp . strftime ( \"%Y%m %d \" ) # date data [ \"t\" ] = timestamp . strftime ( \"%H:%M\" ) # time data [ \"v2\" ] = self . getPVFlow () # PV Generation data [ \"v4\" ] = self . getLoadFlow () # power consumption data [ \"v5\" ] = self . get_inverter_temperature () # inverter temperature data [ \"v6\" ] = self . getVoltage () # voltage return data getDataPvoutput () updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage Source code in pygoodwe/__init__.py 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 def getDataPvoutput ( self ) -> Dict [ str , Union [ str , float ]]: # pylint: disable=invalid-name \"\"\"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage \"\"\" if not self . data : self . getCurrentReadings () # \"time\": \"10/04/2019 14:37:29\" timestamp = datetime . strptime ( self . data . get ( \"info\" , {}) . get ( \"time\" ), \"%m/ %d /%Y %H:%M:%S\" ) data : Dict [ str , Union [ str , float ]] = {} data [ \"d\" ] = timestamp . strftime ( \"%Y%m %d \" ) # date data [ \"t\" ] = timestamp . strftime ( \"%H:%M\" ) # time data [ \"v2\" ] = self . getPVFlow () # PV Generation data [ \"v4\" ] = self . getLoadFlow () # power consumption data [ \"v5\" ] = self . get_inverter_temperature () # inverter temperature data [ \"v6\" ] = self . getVoltage () # voltage return data getPVFlow () returns the current flow amount of the PV panels Source code in pygoodwe/__init__.py 529 530 531 532 533 534 535 536 537 def getPVFlow ( self ) -> float : \"\"\" returns the current flow amount of the PV panels \"\"\" if not self . data : self . getCurrentReadings () if self . data [ \"powerflow\" ][ \"pv\" ] . endswith ( \"(W)\" ): pvflow = self . data [ \"powerflow\" ][ \"pv\" ][: - 3 ] else : pvflow = self . data [ \"powerflow\" ][ \"pv\" ] return float ( pvflow ) getVoltage () gets the current line voltage Source code in pygoodwe/__init__.py 539 540 541 542 543 def getVoltage ( self ) -> float : #type: ignore \"\"\" gets the current line voltage \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ \"inverter\" ][ \"invert_full\" ][ \"vac1\" ]) get_battery_soc () returns the single value state of charge for the batteries in the plant returns : float Source code in pygoodwe/__init__.py 597 598 599 600 601 def get_battery_soc ( self ) -> float : \"\"\"returns the single value state of charge for the batteries in the plant returns : float \"\"\" return self . _get_batteries_soc () get_current_readings ( raw = True , retry = 1 , maxretries = 5 , delay = 30 ) grabs the data and makes sure self.data only has a single inverter Source code in pygoodwe/__init__.py 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def get_current_readings ( self , raw : bool = True , retry : int = 1 , maxretries : int = 5 , delay : int = 30 , ) -> Any : \"\"\" grabs the data and makes sure self.data only has a single inverter \"\"\" # update the data super () . get_current_readings ( raw ) # reduce self.data['inverter'] to a single dict from a list retval = False if self . data . get ( \"inverter\" ): self . data [ \"inverter\" ] = self . data [ \"inverter\" ][ 0 ] else : if retry < maxretries : logging . error ( \"no inverter data, try %s , trying again in %s seconds\" , retry , delay ) time . sleep ( delay ) retval = self . get_current_readings ( raw = raw , retry = retry + 1 , maxretries = maxretries , delay = delay ) else : logging . error ( \"No inverter data after %s retries, quitting.\" , retry ) sys . exit ( f \"No inverter data after { retry } retries, quitting.\" ) return retval get_day_income () gets the current daily income Source code in pygoodwe/__init__.py 545 546 547 548 549 def get_day_income ( self ) -> float : \"\"\" gets the current daily income \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'day_income' ]) get_day_power () gets the total power generated Source code in pygoodwe/__init__.py 563 564 565 566 567 def get_day_power ( self ) -> float : \"\"\" gets the total power generated\"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'power' ]) get_station_location () gets the identified lat and long from the station data Source code in pygoodwe/__init__.py 520 521 522 523 524 525 526 527 def get_station_location ( self ) -> Dict [ str , Union [ str , int ]]: \"\"\" gets the identified lat and long from the station data \"\"\" if not self . data : self . getCurrentReadings () return { \"latitude\" : self . data . get ( \"info\" , {}) . get ( \"latitude\" ), \"longitude\" : self . data . get ( \"info\" , {}) . get ( \"longitude\" ), } get_total_income () gets the total income Source code in pygoodwe/__init__.py 551 552 553 554 555 def get_total_income ( self ) -> float : \"\"\" gets the total income \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'total_income' ]) get_total_power () gets the total power generated Source code in pygoodwe/__init__.py 557 558 559 560 561 def get_total_power ( self ) -> float : \"\"\" gets the total power generated\"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'total_power' ]) loaddata ( filename ) loads the ata from a given file Source code in pygoodwe/__init__.py 481 482 483 484 485 def loaddata ( self , filename : str ) -> None : \"\"\" loads the ata from a given file \"\"\" self . _loaddata ( filename ) if self . data . get ( \"inverter\" ): self . data [ \"inverter\" ] = self . data [ \"inverter\" ][ 0 ]","title":"API Documentation"},{"location":"pygoodwe/#pygoodwe.API","text":"API implementation Source code in pygoodwe/__init__.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 class API (): \"\"\" API implementation \"\"\" #pylint: disable=too-many-instance-attributes,too-many-arguments def __init__ ( self , system_id : str , account : str , password : str , api_url : str = API_URL , log_level : Optional [ str ] = None , user_agent : str = DEFAULT_UA , skipload : bool = False , ) -> None : \"\"\" Options: skipload: don't run self.getCurrentReadings() on init api_url: you can change the API endpoint it hits \"\"\" #TODO: lang: Real Soon Now it'll filter out any responses without that language if log_level is None : if \"LOG_LEVEL\" in os . environ : log_level = os . environ [ \"LOG_LEVEL\" ] else : log_level = \"INFO\" if log_level in ( \"DEBUG\" , \"INFO\" , \"WARNING\" ): log_level = getattr ( logging , os . getenv ( \"LOG_LEVEL\" , \"INFO\" )) logging . basicConfig ( level = log_level , ) self . session = Session () self . system_id = system_id self . account = account self . password = password self . token = '{\"version\":\"v2.0.4\",\"client\":\"ios\",\"language\":\"en\"}' self . global_url = api_url self . base_url = self . global_url logging . debug ( \"API URL: %s \" , self . base_url ) self . user_agent = user_agent if skipload : logging . debug ( \"Skipping initial load of data\" ) self . data : Dict [ str , Any ] = {} else : logging . debug ( \"Doing load of data\" ) self . getCurrentReadings ( raw = True ) def loaddata ( self , filename : str ) -> None : \"\"\" loads a json file of existing data \"\"\" with open ( filename , \"r\" , encoding = \"utf8\" ) as filehandle : self . data = json . loads ( filehandle . read ()) _loaddata = loaddata def get_current_readings ( self , raw : bool = True , retry : int = 1 , maxretries : int = 5 , delay : int = 30 , ) -> Dict [ str , Any ]: # pylint: disable=invalid-name \"\"\" gets readings at the current point in time \"\"\" payload = { \"powerStationId\" : self . system_id } # GOODWE server self . data = self . call ( \"v1/PowerStation/GetMonitorDetailByPowerstationId\" , payload ) retval = self . data if not self . data . get ( \"inverter\" ): if retry < maxretries : logging . error ( \"no inverter data, try %s , trying again in %s seconds\" , retry , delay ) time . sleep ( delay ) retval = self . getCurrentReadings ( raw = raw , retry = retry + 1 , maxretries = maxretries , delay = delay ) else : logging . error ( \"No inverter data after %s retries, quitting.\" , retry ) sys . exit ( f \"No inverter data after { retry } retries, quitting.\" ) return retval # stub function names to old names getCurrentReadings = get_current_readings # def getDayReadings(self, date): # date_s = date.strftime('%Y-%m-%d') # payload = { # 'powerStationId' : self.system_id # } # data = self.call(\"v1/PowerStation/GetMonitorDetailByPowerstationId\", payload) # if 'info' not in data: # logging.warning(date_s + \" - Received bad data \" + str(data)) # return result # result = { # 'latitude' : data['info'].get('latitude'), # 'longitude' : data['info'].get('longitude'), # 'entries' : [] # } # payload = { # 'powerstation_id' : self.system_id, # 'count' : 1, # 'date' : date_s # } # data = self.call(\"PowerStationMonitor/GetPowerStationPowerAndIncomeByDay\", payload) # if len(data) == 0: # logging.warning(date_s + \" - Received bad data \" + str(data)) # return result # eday_kwh = data[0]['p'] # payload = { # 'id' : self.system_id, # 'date' : date_s # } # data = self.call(\"PowerStationMonitor/GetPowerStationPacByDayForApp\", payload) # if 'pacs' not in data: # logging.warning(date_s + \" - Received bad data \" + str(data)) # return result # minutes = 0 # eday_from_power = 0 # for sample in data['pacs']: # parsed_date = datetime.strptime(sample['date'], \"%m/%d/%Y %H:%M:%S\") # next_minutes = parsed_date.hour * 60 + parsed_date.minute # sample['minutes'] = next_minutes - minutes # minutes = next_minutes # eday_from_power += sample['pac'] * sample['minutes'] # factor = eday_kwh / eday_from_power if eday_from_power > 0 else 1 # eday_kwh = 0 # for sample in data['pacs']: # date += timedelta(minutes=sample['minutes']) # pgrid_w = sample['pac'] # increase = pgrid_w * sample['minutes'] * factor # if increase > 0: # eday_kwh += increase # result['entries'].append({ # 'dt' : date, # 'pgrid_w': pgrid_w, # 'eday_kwh': round(eday_kwh, 3) # }) # return result @property def headers ( self ) -> Dict [ str , str ]: \"\"\" request headers \"\"\" return { \"User-Agent\" : self . user_agent , \"Token\" : self . token , } # pylint: disable=invalid-name def getDayDetailedReadingsExcel ( self , export_date : date , timeout : int = 10 , filename : Optional [ str ] = None , ) -> bool : \"\"\"retrieves the detailed daily results of the given date as an Excel sheet, processing the Excel sheet is outside the scope of the current module, possible args: - filename: the path where to write the output file, default \"./Plant_Power_{datestr}.xls \"\"\" datestr = datetime . strftime ( export_date , \"%Y-%m- %d \" ) if filename is None : filename = f \"Plant_Power_ { datestr } .xls\" logging . debug ( \"Will write data for %s to file: %s \" , datestr , filename ) # {\"api\":\"v1/PowerStation/ExportPowerstationPac\",\"param\":{\"date\":\"2021-12-20\",\"pw_id\":\"<my-pw-id>\" payload = { \"str\" : json . dumps ({ \"api\" : \"v1/PowerStation/ExportPowerstationPac\" , \"param\" : { \"date\" : datestr , \"pw_id\" : self . system_id , # since the chart can't be included, use some fixed values that make the sheet look good without it # single pixel white png \"img_base64\" : \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdj+P///38ACfsD/QVDRcoAAAAASUVORK5CYII=\" , #pylint: disable=line-too-long \"img_width\" : 1 , \"img_height\" : 1 , \"is_removesoc\" : 0 , } }) } logging . error ( \"payload: %s \" , payload ) # grab the ID of a file download with the export in it fixed_api_endpoint = self . base_url . replace ( \"/api/\" , \"/GopsApi/Post\" ) # full_url = f\"{fixed_api_endpoint}\" response = requests . post ( url = fixed_api_endpoint , # full_url, params = { \"s\" : \"v1/PowerStation/ExportPowerstationPac\" }, headers = self . headers , data = payload , timeout = timeout , ) response . raise_for_status () # logging.error(response.content) try : data = response . json () except JSONDecodeError : logging . error ( \"Failed to JSON decode result from %s : \\n %s \" , fixed_api_endpoint , response . content , ) return False if not data . get ( \"msg\" ) . lower in ( \"success\" , \"successful\" ): logging . error ( \"Failed to pull from %s - response - %s \" , fixed_api_endpoint , data ) return False download_id = data . get ( \"data\" ) logging . error ( \"Download ID: %s \" , download_id ) if not download_id : logging . error ( \"Couldn't pull download ID by calling %s \" , fixed_api_endpoint ) logging . error ( json . dumps ( download_id )) return False download_payload = { \"id\" : download_id , } file_data = self . call ( \"v1/ReportData/GetStationPowerDataFilePath\" , download_payload , timeout = timeout , ) if file_data and \"file_path\" in file_data : # this is where we actually download the file try : response = requests . get ( file_data [ \"file_path\" ], allow_redirects = True , timeout = timeout , ) response . raise_for_status () except Exception as error_message : # pylint: disable=broad-except logging . error ( \"Failed to query file download path: %s \" , error_message ) # write the file to disk try : with open ( filename , \"wb\" ) as file_handle : file_handle . write ( response . content ) return True except Exception as error_message : # pylint: disable=broad-except logging . error ( \"Failed to write file %s ! Error: %s \" , filename , error_message ) return False return False def do_login ( self , timeout : int = 10 ) -> bool : \"\"\" does the login and token saving thing \"\"\" login_payload = { \"account\" : self . account , \"pwd\" : self . password , } try : response = self . session . post ( self . global_url + \"v1/Common/CrossLogin\" , headers = self . headers , data = login_payload , timeout = timeout , ) response . raise_for_status () except requests . exceptions . RequestException as exp : logging . error ( \"RequestException during do_login(): %s \" , exp ) return False data = response . json () logging . error ( response . cookies ) if data . get ( \"api\" ): logging . debug ( \"Setting base url to %s \" , data . get ( \"api\" )) self . base_url = data . get ( \"api\" ) self . token = json . dumps ( data . get ( \"data\" )) logging . error ( \"Done login, token: %s \" , self . token ) return True def call ( self , url : str , payload : Any , max_tries : int = 3 , timeout : int = 10 , ) -> Dict [ str , Any ]: # pylint: disable=unused-argument \"\"\" makes a call to the API \"\"\" for i in range ( 1 , max_tries ): try : logging . debug ( \"Pulling the following URL: base_url=' %s ', url=' %s '\" , self . base_url , url , ) response = self . session . post ( self . base_url + url , headers = self . headers , data = payload , timeout = timeout , ) response . raise_for_status () data = response . json () logging . debug ( \"call response.json(): %s \" , json . dumps ( data )) # APIs return \"success\", \"Success\", \"Successful\" in the 'msg' # seen \"Successful\" in ExportPowerStationPac # logging.error(\"Msg result %s - %s\", self.base_url + url, data.get('msg', '')) if data . get ( \"msg\" , \"\" ) . lower () in ( \"success\" , \"successful\" , ) and \"data\" in data : # pylint: disable=no-else-return logging . debug ( \"Returning data: %s \" , json . dumps ( data [ \"data\" ], default = str ) ) result : Dict [ str , Any ] = data . get ( \"data\" ) return result logging . debug ( json . dumps ( data )) logging . debug ( \"Logging in again...\" ) if not self . do_login (): logging . error ( \"Failed to log in, bailing\" ) return {} except requests . exceptions . RequestException as exp : logging . error ( \"RequestException: %s \" , exp ) logging . debug ( \"Sleeping for %s seconds...\" , i ) time . sleep ( i ) logging . error ( \"Failed to call GoodWe API url=' %s '\" , self . base_url + url ) return {} @classmethod def parseValue ( cls , value : str , unit : str ) -> float : # pylint: disable=invalid-name \"\"\" takes a string value and reutrns it as a float (if possible) \"\"\" try : return float ( value . rstrip ( unit )) except ValueError as exp : logging . warning ( \"ValueError: %s \" , exp ) return 0.0 def are_batteries_full ( self , fullstate : float = 100.0 ) -> bool : \"\"\"boolean result for if the batteries are full. you can set your given 'full' percentage in float if you want to lower this a little are_batteries_full(fullstate=90.0): returns bool \"\"\" for battery in self . get_batteries_soc (): if battery < fullstate : return False return True def _get_batteries_soc ( self ) -> List [ float ]: \"\"\"returns a list of the state of charge for the batteries returns: list[float,] \"\"\" if not self . data : self . getCurrentReadings () if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"soc\" )) for inverter in self . data [ \"inverter\" ] ] def get_batteries_soc ( self ) -> List [ float ]: \"\"\" return the battery state of charge \"\"\" return self . _get_batteries_soc () def getPVFlow ( self ) -> float : # pylint: disable=invalid-name \"\"\" PV flow data \"\"\" raise NotImplementedError ( \"SingleInverter has this, multi does not\" ) def getVoltage ( self ) -> List [ float ]: # pylint: disable=invalid-name \"\"\" returns the a list of the first AC channel voltages \"\"\" if not self . data : self . getCurrentReadings ( True ) if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"vac1\" )) for inverter in self . data [ \"inverter\" ] ] def getPmeter ( self ) -> float : # pylint: disable=invalid-name \"\"\" gets the current line pmeter \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data . get ( \"inverter\" , {}) . get ( \"invert_full\" , {}) . get ( \"pmeter\" )) def getLoadFlow ( self ) -> List [ float ]: # pylint: disable=invalid-name \"\"\" returns the list of inverter multi-unit load watts \"\"\" raise NotImplementedError ( \"multi-unit load watts isn't implemented yet\" ) def get_inverter_temperature ( self ) -> List [ float ]: \"\"\" returns the list of inverter temperatures \"\"\" if not self . data : self . get_current_readings ( True ) if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"tempperature\" )) for inverter in self . data [ \"inverter\" ] ] def getDataPvoutput ( self ) -> Dict [ str , Union [ str , float ]]: # pylint: disable=invalid-name \"\"\"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage \"\"\" if not self . data : self . getCurrentReadings () # \"time\": \"10/04/2019 14:37:29\" timestamp = datetime . strptime ( self . data . get ( \"info\" , {}) . get ( \"time\" ), \"%m/ %d /%Y %H:%M:%S\" ) data : Dict [ str , Union [ str , float ]] = {} data [ \"d\" ] = timestamp . strftime ( \"%Y%m %d \" ) # date data [ \"t\" ] = timestamp . strftime ( \"%H:%M\" ) # time data [ \"v2\" ] = self . getPVFlow () # PV Generation data [ \"v4\" ] = self . getLoadFlow ()[ 0 ] # power consumption data [ \"v5\" ] = self . get_inverter_temperature ()[ 0 ] # inverter temperature data [ \"v6\" ] = self . getVoltage ()[ 0 ] # voltage return data","title":"API"},{"location":"pygoodwe/#pygoodwe.API.__init__","text":"Options: skipload: don't run self.getCurrentReadings() on init api_url: you can change the API endpoint it hits Source code in pygoodwe/__init__.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def __init__ ( self , system_id : str , account : str , password : str , api_url : str = API_URL , log_level : Optional [ str ] = None , user_agent : str = DEFAULT_UA , skipload : bool = False , ) -> None : \"\"\" Options: skipload: don't run self.getCurrentReadings() on init api_url: you can change the API endpoint it hits \"\"\" #TODO: lang: Real Soon Now it'll filter out any responses without that language if log_level is None : if \"LOG_LEVEL\" in os . environ : log_level = os . environ [ \"LOG_LEVEL\" ] else : log_level = \"INFO\" if log_level in ( \"DEBUG\" , \"INFO\" , \"WARNING\" ): log_level = getattr ( logging , os . getenv ( \"LOG_LEVEL\" , \"INFO\" )) logging . basicConfig ( level = log_level , ) self . session = Session () self . system_id = system_id self . account = account self . password = password self . token = '{\"version\":\"v2.0.4\",\"client\":\"ios\",\"language\":\"en\"}' self . global_url = api_url self . base_url = self . global_url logging . debug ( \"API URL: %s \" , self . base_url ) self . user_agent = user_agent if skipload : logging . debug ( \"Skipping initial load of data\" ) self . data : Dict [ str , Any ] = {} else : logging . debug ( \"Doing load of data\" ) self . getCurrentReadings ( raw = True )","title":"__init__()"},{"location":"pygoodwe/#pygoodwe.API.are_batteries_full","text":"boolean result for if the batteries are full. you can set your given 'full' percentage in float if you want to lower this a little are_batteries_full(fullstate=90.0): returns bool Source code in pygoodwe/__init__.py 370 371 372 373 374 375 376 377 378 def are_batteries_full ( self , fullstate : float = 100.0 ) -> bool : \"\"\"boolean result for if the batteries are full. you can set your given 'full' percentage in float if you want to lower this a little are_batteries_full(fullstate=90.0): returns bool \"\"\" for battery in self . get_batteries_soc (): if battery < fullstate : return False return True","title":"are_batteries_full()"},{"location":"pygoodwe/#pygoodwe.API.call","text":"makes a call to the API Source code in pygoodwe/__init__.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def call ( self , url : str , payload : Any , max_tries : int = 3 , timeout : int = 10 , ) -> Dict [ str , Any ]: # pylint: disable=unused-argument \"\"\" makes a call to the API \"\"\" for i in range ( 1 , max_tries ): try : logging . debug ( \"Pulling the following URL: base_url=' %s ', url=' %s '\" , self . base_url , url , ) response = self . session . post ( self . base_url + url , headers = self . headers , data = payload , timeout = timeout , ) response . raise_for_status () data = response . json () logging . debug ( \"call response.json(): %s \" , json . dumps ( data )) # APIs return \"success\", \"Success\", \"Successful\" in the 'msg' # seen \"Successful\" in ExportPowerStationPac # logging.error(\"Msg result %s - %s\", self.base_url + url, data.get('msg', '')) if data . get ( \"msg\" , \"\" ) . lower () in ( \"success\" , \"successful\" , ) and \"data\" in data : # pylint: disable=no-else-return logging . debug ( \"Returning data: %s \" , json . dumps ( data [ \"data\" ], default = str ) ) result : Dict [ str , Any ] = data . get ( \"data\" ) return result logging . debug ( json . dumps ( data )) logging . debug ( \"Logging in again...\" ) if not self . do_login (): logging . error ( \"Failed to log in, bailing\" ) return {} except requests . exceptions . RequestException as exp : logging . error ( \"RequestException: %s \" , exp ) logging . debug ( \"Sleeping for %s seconds...\" , i ) time . sleep ( i ) logging . error ( \"Failed to call GoodWe API url=' %s '\" , self . base_url + url ) return {}","title":"call()"},{"location":"pygoodwe/#pygoodwe.API.do_login","text":"does the login and token saving thing Source code in pygoodwe/__init__.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def do_login ( self , timeout : int = 10 ) -> bool : \"\"\" does the login and token saving thing \"\"\" login_payload = { \"account\" : self . account , \"pwd\" : self . password , } try : response = self . session . post ( self . global_url + \"v1/Common/CrossLogin\" , headers = self . headers , data = login_payload , timeout = timeout , ) response . raise_for_status () except requests . exceptions . RequestException as exp : logging . error ( \"RequestException during do_login(): %s \" , exp ) return False data = response . json () logging . error ( response . cookies ) if data . get ( \"api\" ): logging . debug ( \"Setting base url to %s \" , data . get ( \"api\" )) self . base_url = data . get ( \"api\" ) self . token = json . dumps ( data . get ( \"data\" )) logging . error ( \"Done login, token: %s \" , self . token ) return True","title":"do_login()"},{"location":"pygoodwe/#pygoodwe.API.getDataPvoutput","text":"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage Source code in pygoodwe/__init__.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 def getDataPvoutput ( self ) -> Dict [ str , Union [ str , float ]]: # pylint: disable=invalid-name \"\"\"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage \"\"\" if not self . data : self . getCurrentReadings () # \"time\": \"10/04/2019 14:37:29\" timestamp = datetime . strptime ( self . data . get ( \"info\" , {}) . get ( \"time\" ), \"%m/ %d /%Y %H:%M:%S\" ) data : Dict [ str , Union [ str , float ]] = {} data [ \"d\" ] = timestamp . strftime ( \"%Y%m %d \" ) # date data [ \"t\" ] = timestamp . strftime ( \"%H:%M\" ) # time data [ \"v2\" ] = self . getPVFlow () # PV Generation data [ \"v4\" ] = self . getLoadFlow ()[ 0 ] # power consumption data [ \"v5\" ] = self . get_inverter_temperature ()[ 0 ] # inverter temperature data [ \"v6\" ] = self . getVoltage ()[ 0 ] # voltage return data","title":"getDataPvoutput()"},{"location":"pygoodwe/#pygoodwe.API.getDayDetailedReadingsExcel","text":"retrieves the detailed daily results of the given date as an Excel sheet, processing the Excel sheet is outside the scope of the current module, possible args: - filename: the path where to write the output file, default \"./Plant_Power_{datestr}.xls Source code in pygoodwe/__init__.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def getDayDetailedReadingsExcel ( self , export_date : date , timeout : int = 10 , filename : Optional [ str ] = None , ) -> bool : \"\"\"retrieves the detailed daily results of the given date as an Excel sheet, processing the Excel sheet is outside the scope of the current module, possible args: - filename: the path where to write the output file, default \"./Plant_Power_{datestr}.xls \"\"\" datestr = datetime . strftime ( export_date , \"%Y-%m- %d \" ) if filename is None : filename = f \"Plant_Power_ { datestr } .xls\" logging . debug ( \"Will write data for %s to file: %s \" , datestr , filename ) # {\"api\":\"v1/PowerStation/ExportPowerstationPac\",\"param\":{\"date\":\"2021-12-20\",\"pw_id\":\"<my-pw-id>\" payload = { \"str\" : json . dumps ({ \"api\" : \"v1/PowerStation/ExportPowerstationPac\" , \"param\" : { \"date\" : datestr , \"pw_id\" : self . system_id , # since the chart can't be included, use some fixed values that make the sheet look good without it # single pixel white png \"img_base64\" : \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdj+P///38ACfsD/QVDRcoAAAAASUVORK5CYII=\" , #pylint: disable=line-too-long \"img_width\" : 1 , \"img_height\" : 1 , \"is_removesoc\" : 0 , } }) } logging . error ( \"payload: %s \" , payload ) # grab the ID of a file download with the export in it fixed_api_endpoint = self . base_url . replace ( \"/api/\" , \"/GopsApi/Post\" ) # full_url = f\"{fixed_api_endpoint}\" response = requests . post ( url = fixed_api_endpoint , # full_url, params = { \"s\" : \"v1/PowerStation/ExportPowerstationPac\" }, headers = self . headers , data = payload , timeout = timeout , ) response . raise_for_status () # logging.error(response.content) try : data = response . json () except JSONDecodeError : logging . error ( \"Failed to JSON decode result from %s : \\n %s \" , fixed_api_endpoint , response . content , ) return False if not data . get ( \"msg\" ) . lower in ( \"success\" , \"successful\" ): logging . error ( \"Failed to pull from %s - response - %s \" , fixed_api_endpoint , data ) return False download_id = data . get ( \"data\" ) logging . error ( \"Download ID: %s \" , download_id ) if not download_id : logging . error ( \"Couldn't pull download ID by calling %s \" , fixed_api_endpoint ) logging . error ( json . dumps ( download_id )) return False download_payload = { \"id\" : download_id , } file_data = self . call ( \"v1/ReportData/GetStationPowerDataFilePath\" , download_payload , timeout = timeout , ) if file_data and \"file_path\" in file_data : # this is where we actually download the file try : response = requests . get ( file_data [ \"file_path\" ], allow_redirects = True , timeout = timeout , ) response . raise_for_status () except Exception as error_message : # pylint: disable=broad-except logging . error ( \"Failed to query file download path: %s \" , error_message ) # write the file to disk try : with open ( filename , \"wb\" ) as file_handle : file_handle . write ( response . content ) return True except Exception as error_message : # pylint: disable=broad-except logging . error ( \"Failed to write file %s ! Error: %s \" , filename , error_message ) return False return False","title":"getDayDetailedReadingsExcel()"},{"location":"pygoodwe/#pygoodwe.API.getLoadFlow","text":"returns the list of inverter multi-unit load watts Source code in pygoodwe/__init__.py 418 419 420 def getLoadFlow ( self ) -> List [ float ]: # pylint: disable=invalid-name \"\"\" returns the list of inverter multi-unit load watts \"\"\" raise NotImplementedError ( \"multi-unit load watts isn't implemented yet\" )","title":"getLoadFlow()"},{"location":"pygoodwe/#pygoodwe.API.getPVFlow","text":"PV flow data Source code in pygoodwe/__init__.py 397 398 399 def getPVFlow ( self ) -> float : # pylint: disable=invalid-name \"\"\" PV flow data \"\"\" raise NotImplementedError ( \"SingleInverter has this, multi does not\" )","title":"getPVFlow()"},{"location":"pygoodwe/#pygoodwe.API.getPmeter","text":"gets the current line pmeter Source code in pygoodwe/__init__.py 412 413 414 415 416 def getPmeter ( self ) -> float : # pylint: disable=invalid-name \"\"\" gets the current line pmeter \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data . get ( \"inverter\" , {}) . get ( \"invert_full\" , {}) . get ( \"pmeter\" ))","title":"getPmeter()"},{"location":"pygoodwe/#pygoodwe.API.getVoltage","text":"returns the a list of the first AC channel voltages Source code in pygoodwe/__init__.py 401 402 403 404 405 406 407 408 409 410 def getVoltage ( self ) -> List [ float ]: # pylint: disable=invalid-name \"\"\" returns the a list of the first AC channel voltages \"\"\" if not self . data : self . getCurrentReadings ( True ) if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"vac1\" )) for inverter in self . data [ \"inverter\" ] ]","title":"getVoltage()"},{"location":"pygoodwe/#pygoodwe.API.get_batteries_soc","text":"return the battery state of charge Source code in pygoodwe/__init__.py 393 394 395 def get_batteries_soc ( self ) -> List [ float ]: \"\"\" return the battery state of charge \"\"\" return self . _get_batteries_soc ()","title":"get_batteries_soc()"},{"location":"pygoodwe/#pygoodwe.API.get_current_readings","text":"gets readings at the current point in time Source code in pygoodwe/__init__.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get_current_readings ( self , raw : bool = True , retry : int = 1 , maxretries : int = 5 , delay : int = 30 , ) -> Dict [ str , Any ]: # pylint: disable=invalid-name \"\"\" gets readings at the current point in time \"\"\" payload = { \"powerStationId\" : self . system_id } # GOODWE server self . data = self . call ( \"v1/PowerStation/GetMonitorDetailByPowerstationId\" , payload ) retval = self . data if not self . data . get ( \"inverter\" ): if retry < maxretries : logging . error ( \"no inverter data, try %s , trying again in %s seconds\" , retry , delay ) time . sleep ( delay ) retval = self . getCurrentReadings ( raw = raw , retry = retry + 1 , maxretries = maxretries , delay = delay ) else : logging . error ( \"No inverter data after %s retries, quitting.\" , retry ) sys . exit ( f \"No inverter data after { retry } retries, quitting.\" ) return retval","title":"get_current_readings()"},{"location":"pygoodwe/#pygoodwe.API.get_inverter_temperature","text":"returns the list of inverter temperatures Source code in pygoodwe/__init__.py 422 423 424 425 426 427 428 429 430 431 def get_inverter_temperature ( self ) -> List [ float ]: \"\"\" returns the list of inverter temperatures \"\"\" if not self . data : self . get_current_readings ( True ) if \"inverter\" not in self . data : raise ValueError ( \"Couldn't get data...\" ) return [ float ( inverter . get ( \"invert_full\" , {}) . get ( \"tempperature\" )) for inverter in self . data [ \"inverter\" ] ]","title":"get_inverter_temperature()"},{"location":"pygoodwe/#pygoodwe.API.headers","text":"request headers Source code in pygoodwe/__init__.py 173 174 175 176 177 178 179 @property def headers ( self ) -> Dict [ str , str ]: \"\"\" request headers \"\"\" return { \"User-Agent\" : self . user_agent , \"Token\" : self . token , }","title":"headers()"},{"location":"pygoodwe/#pygoodwe.API.loaddata","text":"loads a json file of existing data Source code in pygoodwe/__init__.py 77 78 79 80 def loaddata ( self , filename : str ) -> None : \"\"\" loads a json file of existing data \"\"\" with open ( filename , \"r\" , encoding = \"utf8\" ) as filehandle : self . data = json . loads ( filehandle . read ())","title":"loaddata()"},{"location":"pygoodwe/#pygoodwe.API.parseValue","text":"takes a string value and reutrns it as a float (if possible) Source code in pygoodwe/__init__.py 361 362 363 364 365 366 367 368 @classmethod def parseValue ( cls , value : str , unit : str ) -> float : # pylint: disable=invalid-name \"\"\" takes a string value and reutrns it as a float (if possible) \"\"\" try : return float ( value . rstrip ( unit )) except ValueError as exp : logging . warning ( \"ValueError: %s \" , exp ) return 0.0","title":"parseValue()"},{"location":"pygoodwe/#pygoodwe.SingleInverter","text":"Bases: API API implementation for an account with a single inverter Source code in pygoodwe/__init__.py 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 class SingleInverter ( API ): \"\"\" API implementation for an account with a single inverter \"\"\" # pylint: disable=too-many-arguments def __init__ ( self , system_id : str , account : str , password : str , api_url : str = API_URL , log_level : Optional [ str ] = None , user_agent : str = DEFAULT_UA , skipload : bool = False , ) -> None : self . loadflow = 0.0 self . loadflow_direction = \"\" self . data : Dict [ str , Any ] # instantiate the base class super () . __init__ ( system_id , account , password , api_url , log_level , user_agent , skipload ) def loaddata ( self , filename : str ) -> None : \"\"\" loads the ata from a given file \"\"\" self . _loaddata ( filename ) if self . data . get ( \"inverter\" ): self . data [ \"inverter\" ] = self . data [ \"inverter\" ][ 0 ] def get_current_readings ( self , raw : bool = True , retry : int = 1 , maxretries : int = 5 , delay : int = 30 , ) -> Any : \"\"\" grabs the data and makes sure self.data only has a single inverter \"\"\" # update the data super () . get_current_readings ( raw ) # reduce self.data['inverter'] to a single dict from a list retval = False if self . data . get ( \"inverter\" ): self . data [ \"inverter\" ] = self . data [ \"inverter\" ][ 0 ] else : if retry < maxretries : logging . error ( \"no inverter data, try %s , trying again in %s seconds\" , retry , delay ) time . sleep ( delay ) retval = self . get_current_readings ( raw = raw , retry = retry + 1 , maxretries = maxretries , delay = delay ) else : logging . error ( \"No inverter data after %s retries, quitting.\" , retry ) sys . exit ( f \"No inverter data after { retry } retries, quitting.\" ) return retval getCurrentReadings = get_current_readings def _get_station_location ( self ) -> Dict [ str , Union [ str , int ]]: \"\"\" gets the identified lat and long from the station data \"\"\" return self . get_station_location () def get_station_location ( self ) -> Dict [ str , Union [ str , int ]]: \"\"\" gets the identified lat and long from the station data \"\"\" if not self . data : self . getCurrentReadings () return { \"latitude\" : self . data . get ( \"info\" , {}) . get ( \"latitude\" ), \"longitude\" : self . data . get ( \"info\" , {}) . get ( \"longitude\" ), } def getPVFlow ( self ) -> float : \"\"\" returns the current flow amount of the PV panels \"\"\" if not self . data : self . getCurrentReadings () if self . data [ \"powerflow\" ][ \"pv\" ] . endswith ( \"(W)\" ): pvflow = self . data [ \"powerflow\" ][ \"pv\" ][: - 3 ] else : pvflow = self . data [ \"powerflow\" ][ \"pv\" ] return float ( pvflow ) def getVoltage ( self ) -> float : #type: ignore \"\"\" gets the current line voltage \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ \"inverter\" ][ \"invert_full\" ][ \"vac1\" ]) def get_day_income ( self ) -> float : \"\"\" gets the current daily income \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'day_income' ]) def get_total_income ( self ) -> float : \"\"\" gets the total income \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'total_income' ]) def get_total_power ( self ) -> float : \"\"\" gets the total power generated\"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'total_power' ]) def get_day_power ( self ) -> float : \"\"\" gets the total power generated\"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'power' ]) def getLoadFlow ( self ) -> float : # type: ignore if not self . data : self . getCurrentReadings () if self . data [ \"powerflow\" ][ \"bettery\" ] . endswith ( \"(W)\" ): loadflow = float ( self . data [ \"powerflow\" ][ \"load\" ][: - 3 ]) else : loadflow = float ( self . data [ \"powerflow\" ][ \"load\" ]) # I'd love to see the *house* generate power if self . data [ \"powerflow\" ][ \"loadStatus\" ] == - 1 : loadflow_direction = \"Importing\" elif self . data [ \"powerflow\" ][ \"loadStatus\" ] == 1 : loadflow_direction = \"Using Battery\" else : raise ValueError ( f \"Your 'load' is doing something odd - status is ' { self . data [ 'powerflow' ][ 'loadStatus' ] } ''.\" ) # pylint: disable=line-too-long self . loadflow = loadflow self . loadflow_direction = loadflow_direction return loadflow def _get_batteries_soc ( self ) -> float : #type: ignore \"\"\"returns the state of charge of the battery\"\"\" if not self . data : self . getCurrentReadings () if not self . data . get ( \"soc\" , False ): raise ValueError ( \"No state of charge available from data\" ) return float ( self . data [ \"soc\" ] . get ( \"power\" )) def get_battery_soc ( self ) -> float : \"\"\"returns the single value state of charge for the batteries in the plant returns : float \"\"\" return self . _get_batteries_soc () def get_inverter_temperature ( self ) -> float : #type: ignore if not self . data : self . get_current_readings ( True ) return float ( self . data [ \"inverter\" ][ \"tempperature\" ]) def getDataPvoutput ( self ) -> Dict [ str , Union [ str , float ]]: # pylint: disable=invalid-name \"\"\"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage \"\"\" if not self . data : self . getCurrentReadings () # \"time\": \"10/04/2019 14:37:29\" timestamp = datetime . strptime ( self . data . get ( \"info\" , {}) . get ( \"time\" ), \"%m/ %d /%Y %H:%M:%S\" ) data : Dict [ str , Union [ str , float ]] = {} data [ \"d\" ] = timestamp . strftime ( \"%Y%m %d \" ) # date data [ \"t\" ] = timestamp . strftime ( \"%H:%M\" ) # time data [ \"v2\" ] = self . getPVFlow () # PV Generation data [ \"v4\" ] = self . getLoadFlow () # power consumption data [ \"v5\" ] = self . get_inverter_temperature () # inverter temperature data [ \"v6\" ] = self . getVoltage () # voltage return data","title":"SingleInverter"},{"location":"pygoodwe/#pygoodwe.SingleInverter.getDataPvoutput","text":"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage Source code in pygoodwe/__init__.py 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 def getDataPvoutput ( self ) -> Dict [ str , Union [ str , float ]]: # pylint: disable=invalid-name \"\"\"updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage \"\"\" if not self . data : self . getCurrentReadings () # \"time\": \"10/04/2019 14:37:29\" timestamp = datetime . strptime ( self . data . get ( \"info\" , {}) . get ( \"time\" ), \"%m/ %d /%Y %H:%M:%S\" ) data : Dict [ str , Union [ str , float ]] = {} data [ \"d\" ] = timestamp . strftime ( \"%Y%m %d \" ) # date data [ \"t\" ] = timestamp . strftime ( \"%H:%M\" ) # time data [ \"v2\" ] = self . getPVFlow () # PV Generation data [ \"v4\" ] = self . getLoadFlow () # power consumption data [ \"v5\" ] = self . get_inverter_temperature () # inverter temperature data [ \"v6\" ] = self . getVoltage () # voltage return data","title":"getDataPvoutput()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.getPVFlow","text":"returns the current flow amount of the PV panels Source code in pygoodwe/__init__.py 529 530 531 532 533 534 535 536 537 def getPVFlow ( self ) -> float : \"\"\" returns the current flow amount of the PV panels \"\"\" if not self . data : self . getCurrentReadings () if self . data [ \"powerflow\" ][ \"pv\" ] . endswith ( \"(W)\" ): pvflow = self . data [ \"powerflow\" ][ \"pv\" ][: - 3 ] else : pvflow = self . data [ \"powerflow\" ][ \"pv\" ] return float ( pvflow )","title":"getPVFlow()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.getVoltage","text":"gets the current line voltage Source code in pygoodwe/__init__.py 539 540 541 542 543 def getVoltage ( self ) -> float : #type: ignore \"\"\" gets the current line voltage \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ \"inverter\" ][ \"invert_full\" ][ \"vac1\" ])","title":"getVoltage()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_battery_soc","text":"returns the single value state of charge for the batteries in the plant returns : float Source code in pygoodwe/__init__.py 597 598 599 600 601 def get_battery_soc ( self ) -> float : \"\"\"returns the single value state of charge for the batteries in the plant returns : float \"\"\" return self . _get_batteries_soc ()","title":"get_battery_soc()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_current_readings","text":"grabs the data and makes sure self.data only has a single inverter Source code in pygoodwe/__init__.py 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def get_current_readings ( self , raw : bool = True , retry : int = 1 , maxretries : int = 5 , delay : int = 30 , ) -> Any : \"\"\" grabs the data and makes sure self.data only has a single inverter \"\"\" # update the data super () . get_current_readings ( raw ) # reduce self.data['inverter'] to a single dict from a list retval = False if self . data . get ( \"inverter\" ): self . data [ \"inverter\" ] = self . data [ \"inverter\" ][ 0 ] else : if retry < maxretries : logging . error ( \"no inverter data, try %s , trying again in %s seconds\" , retry , delay ) time . sleep ( delay ) retval = self . get_current_readings ( raw = raw , retry = retry + 1 , maxretries = maxretries , delay = delay ) else : logging . error ( \"No inverter data after %s retries, quitting.\" , retry ) sys . exit ( f \"No inverter data after { retry } retries, quitting.\" ) return retval","title":"get_current_readings()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_day_income","text":"gets the current daily income Source code in pygoodwe/__init__.py 545 546 547 548 549 def get_day_income ( self ) -> float : \"\"\" gets the current daily income \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'day_income' ])","title":"get_day_income()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_day_power","text":"gets the total power generated Source code in pygoodwe/__init__.py 563 564 565 566 567 def get_day_power ( self ) -> float : \"\"\" gets the total power generated\"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'power' ])","title":"get_day_power()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_station_location","text":"gets the identified lat and long from the station data Source code in pygoodwe/__init__.py 520 521 522 523 524 525 526 527 def get_station_location ( self ) -> Dict [ str , Union [ str , int ]]: \"\"\" gets the identified lat and long from the station data \"\"\" if not self . data : self . getCurrentReadings () return { \"latitude\" : self . data . get ( \"info\" , {}) . get ( \"latitude\" ), \"longitude\" : self . data . get ( \"info\" , {}) . get ( \"longitude\" ), }","title":"get_station_location()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_total_income","text":"gets the total income Source code in pygoodwe/__init__.py 551 552 553 554 555 def get_total_income ( self ) -> float : \"\"\" gets the total income \"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'total_income' ])","title":"get_total_income()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_total_power","text":"gets the total power generated Source code in pygoodwe/__init__.py 557 558 559 560 561 def get_total_power ( self ) -> float : \"\"\" gets the total power generated\"\"\" if not self . data : self . getCurrentReadings () return float ( self . data [ 'kpi' ][ 'total_power' ])","title":"get_total_power()"},{"location":"pygoodwe/#pygoodwe.SingleInverter.loaddata","text":"loads the ata from a given file Source code in pygoodwe/__init__.py 481 482 483 484 485 def loaddata ( self , filename : str ) -> None : \"\"\" loads the ata from a given file \"\"\" self . _loaddata ( filename ) if self . data . get ( \"inverter\" ): self . data [ \"inverter\" ] = self . data [ \"inverter\" ][ 0 ]","title":"loaddata()"},{"location":"release/","text":"Doing a release Commit things Ensure the version's bumped in pyproject.toml Do the tag: git tag -a v0.0.10 -m 'Lint all the things' Check the tag showed up: git tag Check the tag: git show v0.0.10 Push the tag: git push origin v0.0.10 Draft a release on Github Publish to pypi: poetry publish","title":"Releasing"},{"location":"release/#doing-a-release","text":"Commit things Ensure the version's bumped in pyproject.toml Do the tag: git tag -a v0.0.10 -m 'Lint all the things' Check the tag showed up: git tag Check the tag: git show v0.0.10 Push the tag: git push origin v0.0.10 Draft a release on Github Publish to pypi: poetry publish","title":"Doing a release"}]}